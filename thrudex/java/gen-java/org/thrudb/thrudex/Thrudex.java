/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.thrudb.thrudex;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Thrudex {

  public interface Iface {

    public void ping() throws TException;

    public List<String> getIndices() throws TException;

    public void put(Document d) throws ThrudexException, TException;

    public void remove(Element e) throws ThrudexException, TException;

    public SearchResponse search(SearchQuery s) throws ThrudexException, TException;

    public List<ThrudexException> putList(List<Document> documents) throws ThrudexException, TException;

    public List<ThrudexException> removeList(List<Element> elements) throws ThrudexException, TException;

    public List<SearchResponse> searchList(List<SearchQuery> q) throws ThrudexException, TException;

    public String admin(String op, String data) throws ThrudexException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void ping() throws TException
    {
      send_ping();
      recv_ping();
    }

    public void send_ping() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("ping", TMessageType.CALL, seqid_));
      ping_args args = new ping_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_ping() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      ping_result result = new ping_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public List<String> getIndices() throws TException
    {
      send_getIndices();
      return recv_getIndices();
    }

    public void send_getIndices() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getIndices", TMessageType.CALL, seqid_));
      getIndices_args args = new getIndices_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getIndices() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getIndices_result result = new getIndices_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getIndices failed: unknown result");
    }

    public void put(Document d) throws ThrudexException, TException
    {
      send_put(d);
      recv_put();
    }

    public void send_put(Document d) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("put", TMessageType.CALL, seqid_));
      put_args args = new put_args();
      args.d = d;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_put() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      put_result result = new put_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex != null) {
        throw result.ex;
      }
      return;
    }

    public void remove(Element e) throws ThrudexException, TException
    {
      send_remove(e);
      recv_remove();
    }

    public void send_remove(Element e) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.e = e;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_remove() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex != null) {
        throw result.ex;
      }
      return;
    }

    public SearchResponse search(SearchQuery s) throws ThrudexException, TException
    {
      send_search(s);
      return recv_search();
    }

    public void send_search(SearchQuery s) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("search", TMessageType.CALL, seqid_));
      search_args args = new search_args();
      args.s = s;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public SearchResponse recv_search() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      search_result result = new search_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex != null) {
        throw result.ex;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "search failed: unknown result");
    }

    public List<ThrudexException> putList(List<Document> documents) throws ThrudexException, TException
    {
      send_putList(documents);
      return recv_putList();
    }

    public void send_putList(List<Document> documents) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("putList", TMessageType.CALL, seqid_));
      putList_args args = new putList_args();
      args.documents = documents;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<ThrudexException> recv_putList() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      putList_result result = new putList_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex != null) {
        throw result.ex;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "putList failed: unknown result");
    }

    public List<ThrudexException> removeList(List<Element> elements) throws ThrudexException, TException
    {
      send_removeList(elements);
      return recv_removeList();
    }

    public void send_removeList(List<Element> elements) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("removeList", TMessageType.CALL, seqid_));
      removeList_args args = new removeList_args();
      args.elements = elements;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<ThrudexException> recv_removeList() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      removeList_result result = new removeList_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex != null) {
        throw result.ex;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "removeList failed: unknown result");
    }

    public List<SearchResponse> searchList(List<SearchQuery> q) throws ThrudexException, TException
    {
      send_searchList(q);
      return recv_searchList();
    }

    public void send_searchList(List<SearchQuery> q) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("searchList", TMessageType.CALL, seqid_));
      searchList_args args = new searchList_args();
      args.q = q;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<SearchResponse> recv_searchList() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      searchList_result result = new searchList_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex != null) {
        throw result.ex;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "searchList failed: unknown result");
    }

    public String admin(String op, String data) throws ThrudexException, TException
    {
      send_admin(op, data);
      return recv_admin();
    }

    public void send_admin(String op, String data) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("admin", TMessageType.CALL, seqid_));
      admin_args args = new admin_args();
      args.op = op;
      args.data = data;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_admin() throws ThrudexException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      admin_result result = new admin_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex != null) {
        throw result.ex;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "admin failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("ping", new ping());
      processMap_.put("getIndices", new getIndices());
      processMap_.put("put", new put());
      processMap_.put("remove", new remove());
      processMap_.put("search", new search());
      processMap_.put("putList", new putList());
      processMap_.put("removeList", new removeList());
      processMap_.put("searchList", new searchList());
      processMap_.put("admin", new admin());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class ping implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        ping_args args = new ping_args();
        args.read(iprot);
        iprot.readMessageEnd();
        ping_result result = new ping_result();
        iface_.ping();
        oprot.writeMessageBegin(new TMessage("ping", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getIndices implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getIndices_args args = new getIndices_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getIndices_result result = new getIndices_result();
        result.success = iface_.getIndices();
        oprot.writeMessageBegin(new TMessage("getIndices", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class put implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        put_args args = new put_args();
        args.read(iprot);
        iprot.readMessageEnd();
        put_result result = new put_result();
        try {
          iface_.put(args.d);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("put", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_args args = new remove_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_result result = new remove_result();
        try {
          iface_.remove(args.e);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class search implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        search_args args = new search_args();
        args.read(iprot);
        iprot.readMessageEnd();
        search_result result = new search_result();
        try {
          result.success = iface_.search(args.s);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("search", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class putList implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        putList_args args = new putList_args();
        args.read(iprot);
        iprot.readMessageEnd();
        putList_result result = new putList_result();
        try {
          result.success = iface_.putList(args.documents);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("putList", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class removeList implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        removeList_args args = new removeList_args();
        args.read(iprot);
        iprot.readMessageEnd();
        removeList_result result = new removeList_result();
        try {
          result.success = iface_.removeList(args.elements);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("removeList", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class searchList implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        searchList_args args = new searchList_args();
        args.read(iprot);
        iprot.readMessageEnd();
        searchList_result result = new searchList_result();
        try {
          result.success = iface_.searchList(args.q);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("searchList", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class admin implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        admin_args args = new admin_args();
        args.read(iprot);
        iprot.readMessageEnd();
        admin_result result = new admin_result();
        try {
          result.success = iface_.admin(args.op, args.data);
        } catch (ThrudexException ex) {
          result.ex = ex;
        }
        oprot.writeMessageBegin(new TMessage("admin", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class ping_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("ping_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(ping_args.class, metaDataMap);
    }

    public ping_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public ping_args(ping_args other) {
    }

    @Override
    public ping_args clone() {
      return new ping_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof ping_args)
        return this.equals((ping_args)that);
      return false;
    }

    public boolean equals(ping_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("ping_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class ping_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("ping_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(ping_result.class, metaDataMap);
    }

    public ping_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public ping_result(ping_result other) {
    }

    @Override
    public ping_result clone() {
      return new ping_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof ping_result)
        return this.equals((ping_result)that);
      return false;
    }

    public boolean equals(ping_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("ping_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getIndices_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getIndices_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getIndices_args.class, metaDataMap);
    }

    public getIndices_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getIndices_args(getIndices_args other) {
    }

    @Override
    public getIndices_args clone() {
      return new getIndices_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getIndices_args)
        return this.equals((getIndices_args)that);
      return false;
    }

    public boolean equals(getIndices_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getIndices_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getIndices_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getIndices_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getIndices_result.class, metaDataMap);
    }

    public getIndices_result() {
    }

    public getIndices_result(
      List<String> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getIndices_result(getIndices_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    @Override
    public getIndices_result clone() {
      return new getIndices_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getIndices_result)
        return this.equals((getIndices_result)that);
      return false;
    }

    public boolean equals(getIndices_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  String _elem10;
                  _elem10 = iprot.readString();
                  this.success.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter11 : this.success)          {
            oprot.writeString(_iter11);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getIndices_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class put_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("put_args");
    private static final TField D_FIELD_DESC = new TField("d", TType.STRUCT, (short)1);

    public Document d;
    public static final int D = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(D, new FieldMetaData("d", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Document.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_args.class, metaDataMap);
    }

    public put_args() {
    }

    public put_args(
      Document d)
    {
      this();
      this.d = d;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_args(put_args other) {
      if (other.isSetD()) {
        this.d = new Document(other.d);
      }
    }

    @Override
    public put_args clone() {
      return new put_args(this);
    }

    public Document getD() {
      return this.d;
    }

    public void setD(Document d) {
      this.d = d;
    }

    public void unsetD() {
      this.d = null;
    }

    // Returns true if field d is set (has been asigned a value) and false otherwise
    public boolean isSetD() {
      return this.d != null;
    }

    public void setDIsSet(boolean value) {
      if (!value) {
        this.d = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case D:
        if (value == null) {
          unsetD();
        } else {
          setD((Document)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case D:
        return getD();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case D:
        return isSetD();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_args)
        return this.equals((put_args)that);
      return false;
    }

    public boolean equals(put_args that) {
      if (that == null)
        return false;

      boolean this_present_d = true && this.isSetD();
      boolean that_present_d = true && that.isSetD();
      if (this_present_d || that_present_d) {
        if (!(this_present_d && that_present_d))
          return false;
        if (!this.d.equals(that.d))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case D:
            if (field.type == TType.STRUCT) {
              this.d = new Document();
              this.d.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.d != null) {
        oprot.writeFieldBegin(D_FIELD_DESC);
        this.d.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_args(");
      boolean first = true;

      sb.append("d:");
      if (this.d == null) {
        sb.append("null");
      } else {
        sb.append(this.d);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class put_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("put_result");
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_result.class, metaDataMap);
    }

    public put_result() {
    }

    public put_result(
      ThrudexException ex)
    {
      this();
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_result(put_result other) {
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public put_result clone() {
      return new put_result(this);
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_result)
        return this.equals((put_result)that);
      return false;
    }

    public boolean equals(put_result that) {
      if (that == null)
        return false;

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_result(");
      boolean first = true;

      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public Element e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, Element.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
      Element e)
    {
      this();
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetE()) {
        this.e = new Element(other.e);
      }
    }

    @Override
    public remove_args clone() {
      return new remove_args(this);
    }

    public Element getE() {
      return this.e;
    }

    public void setE(Element e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((Element)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new Element();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.e != null) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_args(");
      boolean first = true;

      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      ThrudexException ex)
    {
      this();
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public remove_result clone() {
      return new remove_result(this);
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_result(");
      boolean first = true;

      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class search_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("search_args");
    private static final TField S_FIELD_DESC = new TField("s", TType.STRUCT, (short)1);

    public SearchQuery s;
    public static final int S = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(S, new FieldMetaData("s", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SearchQuery.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(search_args.class, metaDataMap);
    }

    public search_args() {
    }

    public search_args(
      SearchQuery s)
    {
      this();
      this.s = s;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public search_args(search_args other) {
      if (other.isSetS()) {
        this.s = new SearchQuery(other.s);
      }
    }

    @Override
    public search_args clone() {
      return new search_args(this);
    }

    public SearchQuery getS() {
      return this.s;
    }

    public void setS(SearchQuery s) {
      this.s = s;
    }

    public void unsetS() {
      this.s = null;
    }

    // Returns true if field s is set (has been asigned a value) and false otherwise
    public boolean isSetS() {
      return this.s != null;
    }

    public void setSIsSet(boolean value) {
      if (!value) {
        this.s = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case S:
        if (value == null) {
          unsetS();
        } else {
          setS((SearchQuery)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case S:
        return getS();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case S:
        return isSetS();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof search_args)
        return this.equals((search_args)that);
      return false;
    }

    public boolean equals(search_args that) {
      if (that == null)
        return false;

      boolean this_present_s = true && this.isSetS();
      boolean that_present_s = true && that.isSetS();
      if (this_present_s || that_present_s) {
        if (!(this_present_s && that_present_s))
          return false;
        if (!this.s.equals(that.s))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case S:
            if (field.type == TType.STRUCT) {
              this.s = new SearchQuery();
              this.s.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.s != null) {
        oprot.writeFieldBegin(S_FIELD_DESC);
        this.s.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("search_args(");
      boolean first = true;

      sb.append("s:");
      if (this.s == null) {
        sb.append("null");
      } else {
        sb.append(this.s);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class search_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("search_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public SearchResponse success;
    public static final int SUCCESS = 0;
    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, SearchResponse.class)));
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(search_result.class, metaDataMap);
    }

    public search_result() {
    }

    public search_result(
      SearchResponse success,
      ThrudexException ex)
    {
      this();
      this.success = success;
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public search_result(search_result other) {
      if (other.isSetSuccess()) {
        this.success = new SearchResponse(other.success);
      }
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public search_result clone() {
      return new search_result(this);
    }

    public SearchResponse getSuccess() {
      return this.success;
    }

    public void setSuccess(SearchResponse success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((SearchResponse)value);
        }
        break;

      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof search_result)
        return this.equals((search_result)that);
      return false;
    }

    public boolean equals(search_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new SearchResponse();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("search_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class putList_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("putList_args");
    private static final TField DOCUMENTS_FIELD_DESC = new TField("documents", TType.LIST, (short)1);

    public List<Document> documents;
    public static final int DOCUMENTS = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(DOCUMENTS, new FieldMetaData("documents", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Document.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(putList_args.class, metaDataMap);
    }

    public putList_args() {
    }

    public putList_args(
      List<Document> documents)
    {
      this();
      this.documents = documents;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public putList_args(putList_args other) {
      if (other.isSetDocuments()) {
        List<Document> __this__documents = new ArrayList<Document>();
        for (Document other_element : other.documents) {
          __this__documents.add(new Document(other_element));
        }
        this.documents = __this__documents;
      }
    }

    @Override
    public putList_args clone() {
      return new putList_args(this);
    }

    public int getDocumentsSize() {
      return (this.documents == null) ? 0 : this.documents.size();
    }

    public java.util.Iterator<Document> getDocumentsIterator() {
      return (this.documents == null) ? null : this.documents.iterator();
    }

    public void addToDocuments(Document elem) {
      if (this.documents == null) {
        this.documents = new ArrayList<Document>();
      }
      this.documents.add(elem);
    }

    public List<Document> getDocuments() {
      return this.documents;
    }

    public void setDocuments(List<Document> documents) {
      this.documents = documents;
    }

    public void unsetDocuments() {
      this.documents = null;
    }

    // Returns true if field documents is set (has been asigned a value) and false otherwise
    public boolean isSetDocuments() {
      return this.documents != null;
    }

    public void setDocumentsIsSet(boolean value) {
      if (!value) {
        this.documents = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case DOCUMENTS:
        if (value == null) {
          unsetDocuments();
        } else {
          setDocuments((List<Document>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case DOCUMENTS:
        return getDocuments();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case DOCUMENTS:
        return isSetDocuments();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof putList_args)
        return this.equals((putList_args)that);
      return false;
    }

    public boolean equals(putList_args that) {
      if (that == null)
        return false;

      boolean this_present_documents = true && this.isSetDocuments();
      boolean that_present_documents = true && that.isSetDocuments();
      if (this_present_documents || that_present_documents) {
        if (!(this_present_documents && that_present_documents))
          return false;
        if (!this.documents.equals(that.documents))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case DOCUMENTS:
            if (field.type == TType.LIST) {
              {
                TList _list12 = iprot.readListBegin();
                this.documents = new ArrayList<Document>(_list12.size);
                for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                {
                  Document _elem14;
                  _elem14 = new Document();
                  _elem14.read(iprot);
                  this.documents.add(_elem14);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.documents != null) {
        oprot.writeFieldBegin(DOCUMENTS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.documents.size()));
          for (Document _iter15 : this.documents)          {
            _iter15.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("putList_args(");
      boolean first = true;

      sb.append("documents:");
      if (this.documents == null) {
        sb.append("null");
      } else {
        sb.append(this.documents);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class putList_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("putList_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public List<ThrudexException> success;
    public static final int SUCCESS = 0;
    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRUCT))));
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(putList_result.class, metaDataMap);
    }

    public putList_result() {
    }

    public putList_result(
      List<ThrudexException> success,
      ThrudexException ex)
    {
      this();
      this.success = success;
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public putList_result(putList_result other) {
      if (other.isSetSuccess()) {
        List<ThrudexException> __this__success = new ArrayList<ThrudexException>();
        for (ThrudexException other_element : other.success) {
          __this__success.add(new ThrudexException(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public putList_result clone() {
      return new putList_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<ThrudexException> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(ThrudexException elem) {
      if (this.success == null) {
        this.success = new ArrayList<ThrudexException>();
      }
      this.success.add(elem);
    }

    public List<ThrudexException> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<ThrudexException> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<ThrudexException>)value);
        }
        break;

      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof putList_result)
        return this.equals((putList_result)that);
      return false;
    }

    public boolean equals(putList_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list16 = iprot.readListBegin();
                this.success = new ArrayList<ThrudexException>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  ThrudexException _elem18;
                  _elem18 = new ThrudexException();
                  _elem18.read(iprot);
                  this.success.add(_elem18);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (ThrudexException _iter19 : this.success)          {
            _iter19.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("putList_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class removeList_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("removeList_args");
    private static final TField ELEMENTS_FIELD_DESC = new TField("elements", TType.LIST, (short)1);

    public List<Element> elements;
    public static final int ELEMENTS = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ELEMENTS, new FieldMetaData("elements", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Element.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(removeList_args.class, metaDataMap);
    }

    public removeList_args() {
    }

    public removeList_args(
      List<Element> elements)
    {
      this();
      this.elements = elements;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeList_args(removeList_args other) {
      if (other.isSetElements()) {
        List<Element> __this__elements = new ArrayList<Element>();
        for (Element other_element : other.elements) {
          __this__elements.add(new Element(other_element));
        }
        this.elements = __this__elements;
      }
    }

    @Override
    public removeList_args clone() {
      return new removeList_args(this);
    }

    public int getElementsSize() {
      return (this.elements == null) ? 0 : this.elements.size();
    }

    public java.util.Iterator<Element> getElementsIterator() {
      return (this.elements == null) ? null : this.elements.iterator();
    }

    public void addToElements(Element elem) {
      if (this.elements == null) {
        this.elements = new ArrayList<Element>();
      }
      this.elements.add(elem);
    }

    public List<Element> getElements() {
      return this.elements;
    }

    public void setElements(List<Element> elements) {
      this.elements = elements;
    }

    public void unsetElements() {
      this.elements = null;
    }

    // Returns true if field elements is set (has been asigned a value) and false otherwise
    public boolean isSetElements() {
      return this.elements != null;
    }

    public void setElementsIsSet(boolean value) {
      if (!value) {
        this.elements = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ELEMENTS:
        if (value == null) {
          unsetElements();
        } else {
          setElements((List<Element>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ELEMENTS:
        return getElements();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ELEMENTS:
        return isSetElements();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeList_args)
        return this.equals((removeList_args)that);
      return false;
    }

    public boolean equals(removeList_args that) {
      if (that == null)
        return false;

      boolean this_present_elements = true && this.isSetElements();
      boolean that_present_elements = true && that.isSetElements();
      if (this_present_elements || that_present_elements) {
        if (!(this_present_elements && that_present_elements))
          return false;
        if (!this.elements.equals(that.elements))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ELEMENTS:
            if (field.type == TType.LIST) {
              {
                TList _list20 = iprot.readListBegin();
                this.elements = new ArrayList<Element>(_list20.size);
                for (int _i21 = 0; _i21 < _list20.size; ++_i21)
                {
                  Element _elem22;
                  _elem22 = new Element();
                  _elem22.read(iprot);
                  this.elements.add(_elem22);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.elements != null) {
        oprot.writeFieldBegin(ELEMENTS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.elements.size()));
          for (Element _iter23 : this.elements)          {
            _iter23.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("removeList_args(");
      boolean first = true;

      sb.append("elements:");
      if (this.elements == null) {
        sb.append("null");
      } else {
        sb.append(this.elements);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class removeList_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("removeList_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public List<ThrudexException> success;
    public static final int SUCCESS = 0;
    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRUCT))));
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(removeList_result.class, metaDataMap);
    }

    public removeList_result() {
    }

    public removeList_result(
      List<ThrudexException> success,
      ThrudexException ex)
    {
      this();
      this.success = success;
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public removeList_result(removeList_result other) {
      if (other.isSetSuccess()) {
        List<ThrudexException> __this__success = new ArrayList<ThrudexException>();
        for (ThrudexException other_element : other.success) {
          __this__success.add(new ThrudexException(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public removeList_result clone() {
      return new removeList_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<ThrudexException> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(ThrudexException elem) {
      if (this.success == null) {
        this.success = new ArrayList<ThrudexException>();
      }
      this.success.add(elem);
    }

    public List<ThrudexException> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<ThrudexException> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<ThrudexException>)value);
        }
        break;

      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof removeList_result)
        return this.equals((removeList_result)that);
      return false;
    }

    public boolean equals(removeList_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list24 = iprot.readListBegin();
                this.success = new ArrayList<ThrudexException>(_list24.size);
                for (int _i25 = 0; _i25 < _list24.size; ++_i25)
                {
                  ThrudexException _elem26;
                  _elem26 = new ThrudexException();
                  _elem26.read(iprot);
                  this.success.add(_elem26);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (ThrudexException _iter27 : this.success)          {
            _iter27.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("removeList_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class searchList_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("searchList_args");
    private static final TField Q_FIELD_DESC = new TField("q", TType.LIST, (short)1);

    public List<SearchQuery> q;
    public static final int Q = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(Q, new FieldMetaData("q", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, SearchQuery.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(searchList_args.class, metaDataMap);
    }

    public searchList_args() {
    }

    public searchList_args(
      List<SearchQuery> q)
    {
      this();
      this.q = q;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public searchList_args(searchList_args other) {
      if (other.isSetQ()) {
        List<SearchQuery> __this__q = new ArrayList<SearchQuery>();
        for (SearchQuery other_element : other.q) {
          __this__q.add(new SearchQuery(other_element));
        }
        this.q = __this__q;
      }
    }

    @Override
    public searchList_args clone() {
      return new searchList_args(this);
    }

    public int getQSize() {
      return (this.q == null) ? 0 : this.q.size();
    }

    public java.util.Iterator<SearchQuery> getQIterator() {
      return (this.q == null) ? null : this.q.iterator();
    }

    public void addToQ(SearchQuery elem) {
      if (this.q == null) {
        this.q = new ArrayList<SearchQuery>();
      }
      this.q.add(elem);
    }

    public List<SearchQuery> getQ() {
      return this.q;
    }

    public void setQ(List<SearchQuery> q) {
      this.q = q;
    }

    public void unsetQ() {
      this.q = null;
    }

    // Returns true if field q is set (has been asigned a value) and false otherwise
    public boolean isSetQ() {
      return this.q != null;
    }

    public void setQIsSet(boolean value) {
      if (!value) {
        this.q = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case Q:
        if (value == null) {
          unsetQ();
        } else {
          setQ((List<SearchQuery>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case Q:
        return getQ();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case Q:
        return isSetQ();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof searchList_args)
        return this.equals((searchList_args)that);
      return false;
    }

    public boolean equals(searchList_args that) {
      if (that == null)
        return false;

      boolean this_present_q = true && this.isSetQ();
      boolean that_present_q = true && that.isSetQ();
      if (this_present_q || that_present_q) {
        if (!(this_present_q && that_present_q))
          return false;
        if (!this.q.equals(that.q))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case Q:
            if (field.type == TType.LIST) {
              {
                TList _list28 = iprot.readListBegin();
                this.q = new ArrayList<SearchQuery>(_list28.size);
                for (int _i29 = 0; _i29 < _list28.size; ++_i29)
                {
                  SearchQuery _elem30;
                  _elem30 = new SearchQuery();
                  _elem30.read(iprot);
                  this.q.add(_elem30);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.q != null) {
        oprot.writeFieldBegin(Q_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.q.size()));
          for (SearchQuery _iter31 : this.q)          {
            _iter31.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("searchList_args(");
      boolean first = true;

      sb.append("q:");
      if (this.q == null) {
        sb.append("null");
      } else {
        sb.append(this.q);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class searchList_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("searchList_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public List<SearchResponse> success;
    public static final int SUCCESS = 0;
    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, SearchResponse.class))));
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(searchList_result.class, metaDataMap);
    }

    public searchList_result() {
    }

    public searchList_result(
      List<SearchResponse> success,
      ThrudexException ex)
    {
      this();
      this.success = success;
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public searchList_result(searchList_result other) {
      if (other.isSetSuccess()) {
        List<SearchResponse> __this__success = new ArrayList<SearchResponse>();
        for (SearchResponse other_element : other.success) {
          __this__success.add(new SearchResponse(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public searchList_result clone() {
      return new searchList_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<SearchResponse> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(SearchResponse elem) {
      if (this.success == null) {
        this.success = new ArrayList<SearchResponse>();
      }
      this.success.add(elem);
    }

    public List<SearchResponse> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<SearchResponse> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<SearchResponse>)value);
        }
        break;

      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof searchList_result)
        return this.equals((searchList_result)that);
      return false;
    }

    public boolean equals(searchList_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list32 = iprot.readListBegin();
                this.success = new ArrayList<SearchResponse>(_list32.size);
                for (int _i33 = 0; _i33 < _list32.size; ++_i33)
                {
                  SearchResponse _elem34;
                  _elem34 = new SearchResponse();
                  _elem34.read(iprot);
                  this.success.add(_elem34);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (SearchResponse _iter35 : this.success)          {
            _iter35.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("searchList_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class admin_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("admin_args");
    private static final TField OP_FIELD_DESC = new TField("op", TType.STRING, (short)1);
    private static final TField DATA_FIELD_DESC = new TField("data", TType.STRING, (short)2);

    public String op;
    public static final int OP = 1;
    public String data;
    public static final int DATA = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(OP, new FieldMetaData("op", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(DATA, new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(admin_args.class, metaDataMap);
    }

    public admin_args() {
    }

    public admin_args(
      String op,
      String data)
    {
      this();
      this.op = op;
      this.data = data;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public admin_args(admin_args other) {
      if (other.isSetOp()) {
        this.op = other.op;
      }
      if (other.isSetData()) {
        this.data = other.data;
      }
    }

    @Override
    public admin_args clone() {
      return new admin_args(this);
    }

    public String getOp() {
      return this.op;
    }

    public void setOp(String op) {
      this.op = op;
    }

    public void unsetOp() {
      this.op = null;
    }

    // Returns true if field op is set (has been asigned a value) and false otherwise
    public boolean isSetOp() {
      return this.op != null;
    }

    public void setOpIsSet(boolean value) {
      if (!value) {
        this.op = null;
      }
    }

    public String getData() {
      return this.data;
    }

    public void setData(String data) {
      this.data = data;
    }

    public void unsetData() {
      this.data = null;
    }

    // Returns true if field data is set (has been asigned a value) and false otherwise
    public boolean isSetData() {
      return this.data != null;
    }

    public void setDataIsSet(boolean value) {
      if (!value) {
        this.data = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case OP:
        if (value == null) {
          unsetOp();
        } else {
          setOp((String)value);
        }
        break;

      case DATA:
        if (value == null) {
          unsetData();
        } else {
          setData((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case OP:
        return getOp();

      case DATA:
        return getData();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case OP:
        return isSetOp();
      case DATA:
        return isSetData();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof admin_args)
        return this.equals((admin_args)that);
      return false;
    }

    public boolean equals(admin_args that) {
      if (that == null)
        return false;

      boolean this_present_op = true && this.isSetOp();
      boolean that_present_op = true && that.isSetOp();
      if (this_present_op || that_present_op) {
        if (!(this_present_op && that_present_op))
          return false;
        if (!this.op.equals(that.op))
          return false;
      }

      boolean this_present_data = true && this.isSetData();
      boolean that_present_data = true && that.isSetData();
      if (this_present_data || that_present_data) {
        if (!(this_present_data && that_present_data))
          return false;
        if (!this.data.equals(that.data))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case OP:
            if (field.type == TType.STRING) {
              this.op = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case DATA:
            if (field.type == TType.STRING) {
              this.data = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.op != null) {
        oprot.writeFieldBegin(OP_FIELD_DESC);
        oprot.writeString(this.op);
        oprot.writeFieldEnd();
      }
      if (this.data != null) {
        oprot.writeFieldBegin(DATA_FIELD_DESC);
        oprot.writeString(this.data);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("admin_args(");
      boolean first = true;

      sb.append("op:");
      if (this.op == null) {
        sb.append("null");
      } else {
        sb.append(this.op);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("data:");
      if (this.data == null) {
        sb.append("null");
      } else {
        sb.append(this.data);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class admin_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("admin_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX_FIELD_DESC = new TField("ex", TType.STRUCT, (short)-1);

    public String success;
    public static final int SUCCESS = 0;
    public ThrudexException ex;
    public static final int EX = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(EX, new FieldMetaData("ex", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(admin_result.class, metaDataMap);
    }

    public admin_result() {
    }

    public admin_result(
      String success,
      ThrudexException ex)
    {
      this();
      this.success = success;
      this.ex = ex;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public admin_result(admin_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetEx()) {
        this.ex = new ThrudexException(other.ex);
      }
    }

    @Override
    public admin_result clone() {
      return new admin_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudexException getEx() {
      return this.ex;
    }

    public void setEx(ThrudexException ex) {
      this.ex = ex;
    }

    public void unsetEx() {
      this.ex = null;
    }

    // Returns true if field ex is set (has been asigned a value) and false otherwise
    public boolean isSetEx() {
      return this.ex != null;
    }

    public void setExIsSet(boolean value) {
      if (!value) {
        this.ex = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case EX:
        if (value == null) {
          unsetEx();
        } else {
          setEx((ThrudexException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX:
        return getEx();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX:
        return isSetEx();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof admin_result)
        return this.equals((admin_result)that);
      return false;
    }

    public boolean equals(admin_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex = true && this.isSetEx();
      boolean that_present_ex = true && that.isSetEx();
      if (this_present_ex || that_present_ex) {
        if (!(this_present_ex && that_present_ex))
          return false;
        if (!this.ex.equals(that.ex))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX:
            if (field.type == TType.STRUCT) {
              this.ex = new ThrudexException();
              this.ex.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx()) {
        oprot.writeFieldBegin(EX_FIELD_DESC);
        this.ex.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("admin_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex:");
      if (this.ex == null) {
        sb.append("null");
      } else {
        sb.append(this.ex);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
