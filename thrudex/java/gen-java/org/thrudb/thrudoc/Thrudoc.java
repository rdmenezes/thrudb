/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.thrudb.thrudoc;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class Thrudoc {

  public interface Iface {

    public Set<String> getBuckets() throws ThrudocException, TException;

    public int incr(String bucket, String key, int amount) throws ThrudocException, InvalidBucketException, TException;

    public int decr(String bucket, String key, int amount) throws ThrudocException, InvalidBucketException, TException;

    public void put(String bucket, String key, byte[] value) throws ThrudocException, InvalidBucketException, TException;

    public byte[] get(String bucket, String key) throws ThrudocException, InvalidBucketException, InvalidKeyException, TException;

    public void remove(String bucket, String key) throws ThrudocException, InvalidBucketException, TException;

    public void push_front(String bucket, String key, byte[] value) throws ThrudocException, InvalidBucketException, TException;

    public void push_back(String bucket, String key, byte[] value) throws ThrudocException, InvalidBucketException, TException;

    public byte[] pop_front(String bucket, String key) throws ThrudocException, InvalidBucketException, TException;

    public byte[] pop_back(String bucket, String key) throws ThrudocException, InvalidBucketException, TException;

    public byte[] remove_at(String bucket, String key, int pos) throws ThrudocException, InvalidBucketException, TException;

    public void insert_at(String bucket, String key, byte[] value, int pos) throws ThrudocException, InvalidBucketException, TException;

    public void replace_at(String bucket, String key, byte[] value, int pos) throws ThrudocException, InvalidBucketException, TException;

    public byte[] retrieve_at(String bucket, String key, int pos) throws ThrudocException, InvalidBucketException, TException;

    public List<byte[]> range(String bucket, String key, int start, int end) throws ThrudocException, InvalidBucketException, TException;

    public int length(String bucket, String key) throws ThrudocException, InvalidBucketException, TException;

    public List<String> scan(String bucket, String seed, int limit) throws ThrudocException, InvalidBucketException, TException;

    public String admin(String op, String data) throws ThrudocException, TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public Set<String> getBuckets() throws ThrudocException, TException
    {
      send_getBuckets();
      return recv_getBuckets();
    }

    public void send_getBuckets() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getBuckets", TMessageType.CALL, seqid_));
      getBuckets_args args = new getBuckets_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Set<String> recv_getBuckets() throws ThrudocException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getBuckets_result result = new getBuckets_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getBuckets failed: unknown result");
    }

    public int incr(String bucket, String key, int amount) throws ThrudocException, InvalidBucketException, TException
    {
      send_incr(bucket, key, amount);
      return recv_incr();
    }

    public void send_incr(String bucket, String key, int amount) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("incr", TMessageType.CALL, seqid_));
      incr_args args = new incr_args();
      args.bucket = bucket;
      args.key = key;
      args.amount = amount;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_incr() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      incr_result result = new incr_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "incr failed: unknown result");
    }

    public int decr(String bucket, String key, int amount) throws ThrudocException, InvalidBucketException, TException
    {
      send_decr(bucket, key, amount);
      return recv_decr();
    }

    public void send_decr(String bucket, String key, int amount) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("decr", TMessageType.CALL, seqid_));
      decr_args args = new decr_args();
      args.bucket = bucket;
      args.key = key;
      args.amount = amount;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_decr() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      decr_result result = new decr_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "decr failed: unknown result");
    }

    public void put(String bucket, String key, byte[] value) throws ThrudocException, InvalidBucketException, TException
    {
      send_put(bucket, key, value);
      recv_put();
    }

    public void send_put(String bucket, String key, byte[] value) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("put", TMessageType.CALL, seqid_));
      put_args args = new put_args();
      args.bucket = bucket;
      args.key = key;
      args.value = value;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_put() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      put_result result = new put_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      return;
    }

    public byte[] get(String bucket, String key) throws ThrudocException, InvalidBucketException, InvalidKeyException, TException
    {
      send_get(bucket, key);
      return recv_get();
    }

    public void send_get(String bucket, String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.bucket = bucket;
      args.key = key;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_get() throws ThrudocException, InvalidBucketException, InvalidKeyException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      if (result.ex3 != null) {
        throw result.ex3;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public void remove(String bucket, String key) throws ThrudocException, InvalidBucketException, TException
    {
      send_remove(bucket, key);
      recv_remove();
    }

    public void send_remove(String bucket, String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.bucket = bucket;
      args.key = key;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_remove() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      return;
    }

    public void push_front(String bucket, String key, byte[] value) throws ThrudocException, InvalidBucketException, TException
    {
      send_push_front(bucket, key, value);
      recv_push_front();
    }

    public void send_push_front(String bucket, String key, byte[] value) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("push_front", TMessageType.CALL, seqid_));
      push_front_args args = new push_front_args();
      args.bucket = bucket;
      args.key = key;
      args.value = value;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_push_front() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      push_front_result result = new push_front_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      return;
    }

    public void push_back(String bucket, String key, byte[] value) throws ThrudocException, InvalidBucketException, TException
    {
      send_push_back(bucket, key, value);
      recv_push_back();
    }

    public void send_push_back(String bucket, String key, byte[] value) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("push_back", TMessageType.CALL, seqid_));
      push_back_args args = new push_back_args();
      args.bucket = bucket;
      args.key = key;
      args.value = value;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_push_back() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      push_back_result result = new push_back_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      return;
    }

    public byte[] pop_front(String bucket, String key) throws ThrudocException, InvalidBucketException, TException
    {
      send_pop_front(bucket, key);
      return recv_pop_front();
    }

    public void send_pop_front(String bucket, String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pop_front", TMessageType.CALL, seqid_));
      pop_front_args args = new pop_front_args();
      args.bucket = bucket;
      args.key = key;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_pop_front() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      pop_front_result result = new pop_front_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "pop_front failed: unknown result");
    }

    public byte[] pop_back(String bucket, String key) throws ThrudocException, InvalidBucketException, TException
    {
      send_pop_back(bucket, key);
      return recv_pop_back();
    }

    public void send_pop_back(String bucket, String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pop_back", TMessageType.CALL, seqid_));
      pop_back_args args = new pop_back_args();
      args.bucket = bucket;
      args.key = key;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_pop_back() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      pop_back_result result = new pop_back_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "pop_back failed: unknown result");
    }

    public byte[] remove_at(String bucket, String key, int pos) throws ThrudocException, InvalidBucketException, TException
    {
      send_remove_at(bucket, key, pos);
      return recv_remove_at();
    }

    public void send_remove_at(String bucket, String key, int pos) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove_at", TMessageType.CALL, seqid_));
      remove_at_args args = new remove_at_args();
      args.bucket = bucket;
      args.key = key;
      args.pos = pos;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_remove_at() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_at_result result = new remove_at_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "remove_at failed: unknown result");
    }

    public void insert_at(String bucket, String key, byte[] value, int pos) throws ThrudocException, InvalidBucketException, TException
    {
      send_insert_at(bucket, key, value, pos);
      recv_insert_at();
    }

    public void send_insert_at(String bucket, String key, byte[] value, int pos) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("insert_at", TMessageType.CALL, seqid_));
      insert_at_args args = new insert_at_args();
      args.bucket = bucket;
      args.key = key;
      args.value = value;
      args.pos = pos;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_insert_at() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      insert_at_result result = new insert_at_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      return;
    }

    public void replace_at(String bucket, String key, byte[] value, int pos) throws ThrudocException, InvalidBucketException, TException
    {
      send_replace_at(bucket, key, value, pos);
      recv_replace_at();
    }

    public void send_replace_at(String bucket, String key, byte[] value, int pos) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("replace_at", TMessageType.CALL, seqid_));
      replace_at_args args = new replace_at_args();
      args.bucket = bucket;
      args.key = key;
      args.value = value;
      args.pos = pos;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_replace_at() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      replace_at_result result = new replace_at_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      return;
    }

    public byte[] retrieve_at(String bucket, String key, int pos) throws ThrudocException, InvalidBucketException, TException
    {
      send_retrieve_at(bucket, key, pos);
      return recv_retrieve_at();
    }

    public void send_retrieve_at(String bucket, String key, int pos) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("retrieve_at", TMessageType.CALL, seqid_));
      retrieve_at_args args = new retrieve_at_args();
      args.bucket = bucket;
      args.key = key;
      args.pos = pos;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public byte[] recv_retrieve_at() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      retrieve_at_result result = new retrieve_at_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "retrieve_at failed: unknown result");
    }

    public List<byte[]> range(String bucket, String key, int start, int end) throws ThrudocException, InvalidBucketException, TException
    {
      send_range(bucket, key, start, end);
      return recv_range();
    }

    public void send_range(String bucket, String key, int start, int end) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("range", TMessageType.CALL, seqid_));
      range_args args = new range_args();
      args.bucket = bucket;
      args.key = key;
      args.start = start;
      args.end = end;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<byte[]> recv_range() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      range_result result = new range_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "range failed: unknown result");
    }

    public int length(String bucket, String key) throws ThrudocException, InvalidBucketException, TException
    {
      send_length(bucket, key);
      return recv_length();
    }

    public void send_length(String bucket, String key) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("length", TMessageType.CALL, seqid_));
      length_args args = new length_args();
      args.bucket = bucket;
      args.key = key;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_length() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      length_result result = new length_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "length failed: unknown result");
    }

    public List<String> scan(String bucket, String seed, int limit) throws ThrudocException, InvalidBucketException, TException
    {
      send_scan(bucket, seed, limit);
      return recv_scan();
    }

    public void send_scan(String bucket, String seed, int limit) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("scan", TMessageType.CALL, seqid_));
      scan_args args = new scan_args();
      args.bucket = bucket;
      args.seed = seed;
      args.limit = limit;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_scan() throws ThrudocException, InvalidBucketException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      scan_result result = new scan_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.ex1 != null) {
        throw result.ex1;
      }
      if (result.ex2 != null) {
        throw result.ex2;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scan failed: unknown result");
    }

    public String admin(String op, String data) throws ThrudocException, TException
    {
      send_admin(op, data);
      return recv_admin();
    }

    public void send_admin(String op, String data) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("admin", TMessageType.CALL, seqid_));
      admin_args args = new admin_args();
      args.op = op;
      args.data = data;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_admin() throws ThrudocException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      admin_result result = new admin_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.e != null) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "admin failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("getBuckets", new getBuckets());
      processMap_.put("incr", new incr());
      processMap_.put("decr", new decr());
      processMap_.put("put", new put());
      processMap_.put("get", new get());
      processMap_.put("remove", new remove());
      processMap_.put("push_front", new push_front());
      processMap_.put("push_back", new push_back());
      processMap_.put("pop_front", new pop_front());
      processMap_.put("pop_back", new pop_back());
      processMap_.put("remove_at", new remove_at());
      processMap_.put("insert_at", new insert_at());
      processMap_.put("replace_at", new replace_at());
      processMap_.put("retrieve_at", new retrieve_at());
      processMap_.put("range", new range());
      processMap_.put("length", new length());
      processMap_.put("scan", new scan());
      processMap_.put("admin", new admin());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class getBuckets implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getBuckets_args args = new getBuckets_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getBuckets_result result = new getBuckets_result();
        try {
          result.success = iface_.getBuckets();
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        }
        oprot.writeMessageBegin(new TMessage("getBuckets", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class incr implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        incr_args args = new incr_args();
        args.read(iprot);
        iprot.readMessageEnd();
        incr_result result = new incr_result();
        try {
          result.success = iface_.incr(args.bucket, args.key, args.amount);
          result.__isset.success = true;
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("incr", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class decr implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        decr_args args = new decr_args();
        args.read(iprot);
        iprot.readMessageEnd();
        decr_result result = new decr_result();
        try {
          result.success = iface_.decr(args.bucket, args.key, args.amount);
          result.__isset.success = true;
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("decr", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class put implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        put_args args = new put_args();
        args.read(iprot);
        iprot.readMessageEnd();
        put_result result = new put_result();
        try {
          iface_.put(args.bucket, args.key, args.value);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("put", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_args args = new get_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_result result = new get_result();
        try {
          result.success = iface_.get(args.bucket, args.key);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        } catch (InvalidKeyException ex3) {
          result.ex3 = ex3;
        }
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_args args = new remove_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_result result = new remove_result();
        try {
          iface_.remove(args.bucket, args.key);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class push_front implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        push_front_args args = new push_front_args();
        args.read(iprot);
        iprot.readMessageEnd();
        push_front_result result = new push_front_result();
        try {
          iface_.push_front(args.bucket, args.key, args.value);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("push_front", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class push_back implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        push_back_args args = new push_back_args();
        args.read(iprot);
        iprot.readMessageEnd();
        push_back_result result = new push_back_result();
        try {
          iface_.push_back(args.bucket, args.key, args.value);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("push_back", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pop_front implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pop_front_args args = new pop_front_args();
        args.read(iprot);
        iprot.readMessageEnd();
        pop_front_result result = new pop_front_result();
        try {
          result.success = iface_.pop_front(args.bucket, args.key);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("pop_front", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pop_back implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pop_back_args args = new pop_back_args();
        args.read(iprot);
        iprot.readMessageEnd();
        pop_back_result result = new pop_back_result();
        try {
          result.success = iface_.pop_back(args.bucket, args.key);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("pop_back", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove_at implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_at_args args = new remove_at_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_at_result result = new remove_at_result();
        try {
          result.success = iface_.remove_at(args.bucket, args.key, args.pos);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("remove_at", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class insert_at implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        insert_at_args args = new insert_at_args();
        args.read(iprot);
        iprot.readMessageEnd();
        insert_at_result result = new insert_at_result();
        try {
          iface_.insert_at(args.bucket, args.key, args.value, args.pos);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("insert_at", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class replace_at implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        replace_at_args args = new replace_at_args();
        args.read(iprot);
        iprot.readMessageEnd();
        replace_at_result result = new replace_at_result();
        try {
          iface_.replace_at(args.bucket, args.key, args.value, args.pos);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("replace_at", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class retrieve_at implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        retrieve_at_args args = new retrieve_at_args();
        args.read(iprot);
        iprot.readMessageEnd();
        retrieve_at_result result = new retrieve_at_result();
        try {
          result.success = iface_.retrieve_at(args.bucket, args.key, args.pos);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("retrieve_at", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class range implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        range_args args = new range_args();
        args.read(iprot);
        iprot.readMessageEnd();
        range_result result = new range_result();
        try {
          result.success = iface_.range(args.bucket, args.key, args.start, args.end);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("range", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class length implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        length_args args = new length_args();
        args.read(iprot);
        iprot.readMessageEnd();
        length_result result = new length_result();
        try {
          result.success = iface_.length(args.bucket, args.key);
          result.__isset.success = true;
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("length", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class scan implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        scan_args args = new scan_args();
        args.read(iprot);
        iprot.readMessageEnd();
        scan_result result = new scan_result();
        try {
          result.success = iface_.scan(args.bucket, args.seed, args.limit);
        } catch (ThrudocException ex1) {
          result.ex1 = ex1;
        } catch (InvalidBucketException ex2) {
          result.ex2 = ex2;
        }
        oprot.writeMessageBegin(new TMessage("scan", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class admin implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        admin_args args = new admin_args();
        args.read(iprot);
        iprot.readMessageEnd();
        admin_result result = new admin_result();
        try {
          result.success = iface_.admin(args.op, args.data);
        } catch (ThrudocException e) {
          result.e = e;
        }
        oprot.writeMessageBegin(new TMessage("admin", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class getBuckets_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getBuckets_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getBuckets_args.class, metaDataMap);
    }

    public getBuckets_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getBuckets_args(getBuckets_args other) {
    }

    @Override
    public getBuckets_args clone() {
      return new getBuckets_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getBuckets_args)
        return this.equals((getBuckets_args)that);
      return false;
    }

    public boolean equals(getBuckets_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getBuckets_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getBuckets_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getBuckets_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.SET, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);

    public Set<String> success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new SetMetaData(TType.SET, 
              new FieldValueMetaData(TType.STRING))));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getBuckets_result.class, metaDataMap);
    }

    public getBuckets_result() {
    }

    public getBuckets_result(
      Set<String> success,
      ThrudocException ex1)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getBuckets_result(getBuckets_result other) {
      if (other.isSetSuccess()) {
        Set<String> __this__success = new HashSet<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
    }

    @Override
    public getBuckets_result clone() {
      return new getBuckets_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new HashSet<String>();
      }
      this.success.add(elem);
    }

    public Set<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(Set<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Set<String>)value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getBuckets_result)
        return this.equals((getBuckets_result)that);
      return false;
    }

    public boolean equals(getBuckets_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.SET) {
              {
                TSet _set0 = iprot.readSetBegin();
                this.success = new HashSet<String>(2*_set0.size);
                for (int _i1 = 0; _i1 < _set0.size; ++_i1)
                {
                  String _elem2;
                  _elem2 = iprot.readString();
                  this.success.add(_elem2);
                }
                iprot.readSetEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeSetBegin(new TSet(TType.STRING, this.success.size()));
          for (String _iter3 : this.success)          {
            oprot.writeString(_iter3);
          }
          oprot.writeSetEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getBuckets_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class incr_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("incr_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField AMOUNT_FIELD_DESC = new TField("amount", TType.I32, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public int amount;
    public static final int AMOUNT = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean amount = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(AMOUNT, new FieldMetaData("amount", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(incr_args.class, metaDataMap);
    }

    public incr_args() {
      this.amount = 1;

    }

    public incr_args(
      String bucket,
      String key,
      int amount)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.amount = amount;
      this.__isset.amount = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public incr_args(incr_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      __isset.amount = other.__isset.amount;
      this.amount = other.amount;
    }

    @Override
    public incr_args clone() {
      return new incr_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public int getAmount() {
      return this.amount;
    }

    public void setAmount(int amount) {
      this.amount = amount;
      this.__isset.amount = true;
    }

    public void unsetAmount() {
      this.__isset.amount = false;
    }

    // Returns true if field amount is set (has been asigned a value) and false otherwise
    public boolean isSetAmount() {
      return this.__isset.amount;
    }

    public void setAmountIsSet(boolean value) {
      this.__isset.amount = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case AMOUNT:
        if (value == null) {
          unsetAmount();
        } else {
          setAmount((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case AMOUNT:
        return new Integer(getAmount());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case AMOUNT:
        return isSetAmount();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof incr_args)
        return this.equals((incr_args)that);
      return false;
    }

    public boolean equals(incr_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_amount = true;
      boolean that_present_amount = true;
      if (this_present_amount || that_present_amount) {
        if (!(this_present_amount && that_present_amount))
          return false;
        if (this.amount != that.amount)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case AMOUNT:
            if (field.type == TType.I32) {
              this.amount = iprot.readI32();
              this.__isset.amount = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(AMOUNT_FIELD_DESC);
      oprot.writeI32(this.amount);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("incr_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("amount:");
      sb.append(this.amount);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class incr_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("incr_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public int success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(incr_result.class, metaDataMap);
    }

    public incr_result() {
    }

    public incr_result(
      int success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public incr_result(incr_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public incr_result clone() {
      return new incr_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof incr_result)
        return this.equals((incr_result)that);
      return false;
    }

    public boolean equals(incr_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("incr_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class decr_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("decr_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField AMOUNT_FIELD_DESC = new TField("amount", TType.I32, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public int amount;
    public static final int AMOUNT = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean amount = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(AMOUNT, new FieldMetaData("amount", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(decr_args.class, metaDataMap);
    }

    public decr_args() {
      this.amount = 1;

    }

    public decr_args(
      String bucket,
      String key,
      int amount)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.amount = amount;
      this.__isset.amount = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public decr_args(decr_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      __isset.amount = other.__isset.amount;
      this.amount = other.amount;
    }

    @Override
    public decr_args clone() {
      return new decr_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public int getAmount() {
      return this.amount;
    }

    public void setAmount(int amount) {
      this.amount = amount;
      this.__isset.amount = true;
    }

    public void unsetAmount() {
      this.__isset.amount = false;
    }

    // Returns true if field amount is set (has been asigned a value) and false otherwise
    public boolean isSetAmount() {
      return this.__isset.amount;
    }

    public void setAmountIsSet(boolean value) {
      this.__isset.amount = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case AMOUNT:
        if (value == null) {
          unsetAmount();
        } else {
          setAmount((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case AMOUNT:
        return new Integer(getAmount());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case AMOUNT:
        return isSetAmount();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof decr_args)
        return this.equals((decr_args)that);
      return false;
    }

    public boolean equals(decr_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_amount = true;
      boolean that_present_amount = true;
      if (this_present_amount || that_present_amount) {
        if (!(this_present_amount && that_present_amount))
          return false;
        if (this.amount != that.amount)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case AMOUNT:
            if (field.type == TType.I32) {
              this.amount = iprot.readI32();
              this.__isset.amount = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(AMOUNT_FIELD_DESC);
      oprot.writeI32(this.amount);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("decr_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("amount:");
      sb.append(this.amount);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class decr_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("decr_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public int success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(decr_result.class, metaDataMap);
    }

    public decr_result() {
    }

    public decr_result(
      int success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public decr_result(decr_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public decr_result clone() {
      return new decr_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof decr_result)
        return this.equals((decr_result)that);
      return false;
    }

    public boolean equals(decr_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("decr_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class put_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("put_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public byte[] value;
    public static final int VALUE = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_args.class, metaDataMap);
    }

    public put_args() {
    }

    public put_args(
      String bucket,
      String key,
      byte[] value)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.value = value;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_args(put_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
    }

    @Override
    public put_args clone() {
      return new put_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public void setValue(byte[] value) {
      this.value = value;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case VALUE:
        return getValue();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case VALUE:
        return isSetValue();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_args)
        return this.equals((put_args)that);
      return false;
    }

    public boolean equals(put_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class put_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("put_result");
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_result.class, metaDataMap);
    }

    public put_result() {
    }

    public put_result(
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_result(put_result other) {
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public put_result clone() {
      return new put_result(this);
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_result)
        return this.equals((put_result)that);
      return false;
    }

    public boolean equals(put_result that) {
      if (that == null)
        return false;

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_result(");
      boolean first = true;

      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
      String bucket,
      String key)
    {
      this();
      this.bucket = bucket;
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
    }

    @Override
    public get_args clone() {
      return new get_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);
    private static final TField EX3_FIELD_DESC = new TField("ex3", TType.STRUCT, (short)3);

    public byte[] success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;
    public InvalidKeyException ex3;
    public static final int EX3 = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX3, new FieldMetaData("ex3", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      byte[] success,
      ThrudocException ex1,
      InvalidBucketException ex2,
      InvalidKeyException ex3)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
      this.ex3 = ex3;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = new byte[other.success.length];
        System.arraycopy(other.success, 0, success, 0, other.success.length);
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
      if (other.isSetEx3()) {
        this.ex3 = new InvalidKeyException(other.ex3);
      }
    }

    @Override
    public get_result clone() {
      return new get_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public void setSuccess(byte[] success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public InvalidKeyException getEx3() {
      return this.ex3;
    }

    public void setEx3(InvalidKeyException ex3) {
      this.ex3 = ex3;
    }

    public void unsetEx3() {
      this.ex3 = null;
    }

    // Returns true if field ex3 is set (has been asigned a value) and false otherwise
    public boolean isSetEx3() {
      return this.ex3 != null;
    }

    public void setEx3IsSet(boolean value) {
      if (!value) {
        this.ex3 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      case EX3:
        if (value == null) {
          unsetEx3();
        } else {
          setEx3((InvalidKeyException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      case EX3:
        return getEx3();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      case EX3:
        return isSetEx3();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      boolean this_present_ex3 = true && this.isSetEx3();
      boolean that_present_ex3 = true && that.isSetEx3();
      if (this_present_ex3 || that_present_ex3) {
        if (!(this_present_ex3 && that_present_ex3))
          return false;
        if (!this.ex3.equals(that.ex3))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX3:
            if (field.type == TType.STRUCT) {
              this.ex3 = new InvalidKeyException();
              this.ex3.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx3()) {
        oprot.writeFieldBegin(EX3_FIELD_DESC);
        this.ex3.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
          int __success_size = Math.min(this.success.length, 128);
          for (int i = 0; i < __success_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.success[i]).length() > 1 ? Integer.toHexString(this.success[i]).substring(Integer.toHexString(this.success[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.success[i]).toUpperCase());
          }
          if (this.success.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex3:");
      if (this.ex3 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex3);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
      String bucket,
      String key)
    {
      this();
      this.bucket = bucket;
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
    }

    @Override
    public remove_args clone() {
      return new remove_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public remove_result clone() {
      return new remove_result(this);
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_result(");
      boolean first = true;

      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class push_front_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("push_front_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public byte[] value;
    public static final int VALUE = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(push_front_args.class, metaDataMap);
    }

    public push_front_args() {
    }

    public push_front_args(
      String bucket,
      String key,
      byte[] value)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.value = value;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public push_front_args(push_front_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
    }

    @Override
    public push_front_args clone() {
      return new push_front_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public void setValue(byte[] value) {
      this.value = value;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case VALUE:
        return getValue();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case VALUE:
        return isSetValue();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof push_front_args)
        return this.equals((push_front_args)that);
      return false;
    }

    public boolean equals(push_front_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("push_front_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class push_front_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("push_front_result");
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(push_front_result.class, metaDataMap);
    }

    public push_front_result() {
    }

    public push_front_result(
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public push_front_result(push_front_result other) {
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public push_front_result clone() {
      return new push_front_result(this);
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof push_front_result)
        return this.equals((push_front_result)that);
      return false;
    }

    public boolean equals(push_front_result that) {
      if (that == null)
        return false;

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("push_front_result(");
      boolean first = true;

      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class push_back_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("push_back_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public byte[] value;
    public static final int VALUE = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(push_back_args.class, metaDataMap);
    }

    public push_back_args() {
    }

    public push_back_args(
      String bucket,
      String key,
      byte[] value)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.value = value;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public push_back_args(push_back_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
    }

    @Override
    public push_back_args clone() {
      return new push_back_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public void setValue(byte[] value) {
      this.value = value;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case VALUE:
        return getValue();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case VALUE:
        return isSetValue();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof push_back_args)
        return this.equals((push_back_args)that);
      return false;
    }

    public boolean equals(push_back_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("push_back_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class push_back_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("push_back_result");
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(push_back_result.class, metaDataMap);
    }

    public push_back_result() {
    }

    public push_back_result(
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public push_back_result(push_back_result other) {
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public push_back_result clone() {
      return new push_back_result(this);
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof push_back_result)
        return this.equals((push_back_result)that);
      return false;
    }

    public boolean equals(push_back_result that) {
      if (that == null)
        return false;

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("push_back_result(");
      boolean first = true;

      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pop_front_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pop_front_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pop_front_args.class, metaDataMap);
    }

    public pop_front_args() {
    }

    public pop_front_args(
      String bucket,
      String key)
    {
      this();
      this.bucket = bucket;
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pop_front_args(pop_front_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
    }

    @Override
    public pop_front_args clone() {
      return new pop_front_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pop_front_args)
        return this.equals((pop_front_args)that);
      return false;
    }

    public boolean equals(pop_front_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pop_front_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pop_front_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pop_front_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public byte[] success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pop_front_result.class, metaDataMap);
    }

    public pop_front_result() {
    }

    public pop_front_result(
      byte[] success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pop_front_result(pop_front_result other) {
      if (other.isSetSuccess()) {
        this.success = new byte[other.success.length];
        System.arraycopy(other.success, 0, success, 0, other.success.length);
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public pop_front_result clone() {
      return new pop_front_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public void setSuccess(byte[] success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pop_front_result)
        return this.equals((pop_front_result)that);
      return false;
    }

    public boolean equals(pop_front_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pop_front_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
          int __success_size = Math.min(this.success.length, 128);
          for (int i = 0; i < __success_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.success[i]).length() > 1 ? Integer.toHexString(this.success[i]).substring(Integer.toHexString(this.success[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.success[i]).toUpperCase());
          }
          if (this.success.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pop_back_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pop_back_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pop_back_args.class, metaDataMap);
    }

    public pop_back_args() {
    }

    public pop_back_args(
      String bucket,
      String key)
    {
      this();
      this.bucket = bucket;
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pop_back_args(pop_back_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
    }

    @Override
    public pop_back_args clone() {
      return new pop_back_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pop_back_args)
        return this.equals((pop_back_args)that);
      return false;
    }

    public boolean equals(pop_back_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pop_back_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pop_back_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("pop_back_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public byte[] success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pop_back_result.class, metaDataMap);
    }

    public pop_back_result() {
    }

    public pop_back_result(
      byte[] success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pop_back_result(pop_back_result other) {
      if (other.isSetSuccess()) {
        this.success = new byte[other.success.length];
        System.arraycopy(other.success, 0, success, 0, other.success.length);
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public pop_back_result clone() {
      return new pop_back_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public void setSuccess(byte[] success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pop_back_result)
        return this.equals((pop_back_result)that);
      return false;
    }

    public boolean equals(pop_back_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pop_back_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
          int __success_size = Math.min(this.success.length, 128);
          for (int i = 0; i < __success_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.success[i]).length() > 1 ? Integer.toHexString(this.success[i]).substring(Integer.toHexString(this.success[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.success[i]).toUpperCase());
          }
          if (this.success.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_at_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_at_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField POS_FIELD_DESC = new TField("pos", TType.I32, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public int pos;
    public static final int POS = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean pos = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(POS, new FieldMetaData("pos", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_at_args.class, metaDataMap);
    }

    public remove_at_args() {
    }

    public remove_at_args(
      String bucket,
      String key,
      int pos)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.pos = pos;
      this.__isset.pos = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_at_args(remove_at_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      __isset.pos = other.__isset.pos;
      this.pos = other.pos;
    }

    @Override
    public remove_at_args clone() {
      return new remove_at_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public int getPos() {
      return this.pos;
    }

    public void setPos(int pos) {
      this.pos = pos;
      this.__isset.pos = true;
    }

    public void unsetPos() {
      this.__isset.pos = false;
    }

    // Returns true if field pos is set (has been asigned a value) and false otherwise
    public boolean isSetPos() {
      return this.__isset.pos;
    }

    public void setPosIsSet(boolean value) {
      this.__isset.pos = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case POS:
        if (value == null) {
          unsetPos();
        } else {
          setPos((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case POS:
        return new Integer(getPos());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case POS:
        return isSetPos();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_at_args)
        return this.equals((remove_at_args)that);
      return false;
    }

    public boolean equals(remove_at_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_pos = true;
      boolean that_present_pos = true;
      if (this_present_pos || that_present_pos) {
        if (!(this_present_pos && that_present_pos))
          return false;
        if (this.pos != that.pos)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case POS:
            if (field.type == TType.I32) {
              this.pos = iprot.readI32();
              this.__isset.pos = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(POS_FIELD_DESC);
      oprot.writeI32(this.pos);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_at_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pos:");
      sb.append(this.pos);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_at_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_at_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public byte[] success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_at_result.class, metaDataMap);
    }

    public remove_at_result() {
    }

    public remove_at_result(
      byte[] success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_at_result(remove_at_result other) {
      if (other.isSetSuccess()) {
        this.success = new byte[other.success.length];
        System.arraycopy(other.success, 0, success, 0, other.success.length);
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public remove_at_result clone() {
      return new remove_at_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public void setSuccess(byte[] success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_at_result)
        return this.equals((remove_at_result)that);
      return false;
    }

    public boolean equals(remove_at_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_at_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
          int __success_size = Math.min(this.success.length, 128);
          for (int i = 0; i < __success_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.success[i]).length() > 1 ? Integer.toHexString(this.success[i]).substring(Integer.toHexString(this.success[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.success[i]).toUpperCase());
          }
          if (this.success.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class insert_at_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_at_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);
    private static final TField POS_FIELD_DESC = new TField("pos", TType.I32, (short)4);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public byte[] value;
    public static final int VALUE = 3;
    public int pos;
    public static final int POS = 4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean pos = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(POS, new FieldMetaData("pos", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_at_args.class, metaDataMap);
    }

    public insert_at_args() {
    }

    public insert_at_args(
      String bucket,
      String key,
      byte[] value,
      int pos)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.value = value;
      this.pos = pos;
      this.__isset.pos = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_at_args(insert_at_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
      __isset.pos = other.__isset.pos;
      this.pos = other.pos;
    }

    @Override
    public insert_at_args clone() {
      return new insert_at_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public void setValue(byte[] value) {
      this.value = value;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public int getPos() {
      return this.pos;
    }

    public void setPos(int pos) {
      this.pos = pos;
      this.__isset.pos = true;
    }

    public void unsetPos() {
      this.__isset.pos = false;
    }

    // Returns true if field pos is set (has been asigned a value) and false otherwise
    public boolean isSetPos() {
      return this.__isset.pos;
    }

    public void setPosIsSet(boolean value) {
      this.__isset.pos = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      case POS:
        if (value == null) {
          unsetPos();
        } else {
          setPos((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case VALUE:
        return getValue();

      case POS:
        return new Integer(getPos());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case VALUE:
        return isSetValue();
      case POS:
        return isSetPos();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_at_args)
        return this.equals((insert_at_args)that);
      return false;
    }

    public boolean equals(insert_at_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      boolean this_present_pos = true;
      boolean that_present_pos = true;
      if (this_present_pos || that_present_pos) {
        if (!(this_present_pos && that_present_pos))
          return false;
        if (this.pos != that.pos)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case POS:
            if (field.type == TType.I32) {
              this.pos = iprot.readI32();
              this.__isset.pos = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(POS_FIELD_DESC);
      oprot.writeI32(this.pos);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_at_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pos:");
      sb.append(this.pos);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class insert_at_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_at_result");
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_at_result.class, metaDataMap);
    }

    public insert_at_result() {
    }

    public insert_at_result(
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_at_result(insert_at_result other) {
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public insert_at_result clone() {
      return new insert_at_result(this);
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_at_result)
        return this.equals((insert_at_result)that);
      return false;
    }

    public boolean equals(insert_at_result that) {
      if (that == null)
        return false;

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_at_result(");
      boolean first = true;

      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class replace_at_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("replace_at_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);
    private static final TField POS_FIELD_DESC = new TField("pos", TType.I32, (short)4);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public byte[] value;
    public static final int VALUE = 3;
    public int pos;
    public static final int POS = 4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean pos = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(POS, new FieldMetaData("pos", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(replace_at_args.class, metaDataMap);
    }

    public replace_at_args() {
    }

    public replace_at_args(
      String bucket,
      String key,
      byte[] value,
      int pos)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.value = value;
      this.pos = pos;
      this.__isset.pos = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public replace_at_args(replace_at_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      if (other.isSetValue()) {
        this.value = new byte[other.value.length];
        System.arraycopy(other.value, 0, value, 0, other.value.length);
      }
      __isset.pos = other.__isset.pos;
      this.pos = other.pos;
    }

    @Override
    public replace_at_args clone() {
      return new replace_at_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public byte[] getValue() {
      return this.value;
    }

    public void setValue(byte[] value) {
      this.value = value;
    }

    public void unsetValue() {
      this.value = null;
    }

    // Returns true if field value is set (has been asigned a value) and false otherwise
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public int getPos() {
      return this.pos;
    }

    public void setPos(int pos) {
      this.pos = pos;
      this.__isset.pos = true;
    }

    public void unsetPos() {
      this.__isset.pos = false;
    }

    // Returns true if field pos is set (has been asigned a value) and false otherwise
    public boolean isSetPos() {
      return this.__isset.pos;
    }

    public void setPosIsSet(boolean value) {
      this.__isset.pos = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((byte[])value);
        }
        break;

      case POS:
        if (value == null) {
          unsetPos();
        } else {
          setPos((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case VALUE:
        return getValue();

      case POS:
        return new Integer(getPos());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case VALUE:
        return isSetValue();
      case POS:
        return isSetPos();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof replace_at_args)
        return this.equals((replace_at_args)that);
      return false;
    }

    public boolean equals(replace_at_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!java.util.Arrays.equals(this.value, that.value))
          return false;
      }

      boolean this_present_pos = true;
      boolean that_present_pos = true;
      if (this_present_pos || that_present_pos) {
        if (!(this_present_pos && that_present_pos))
          return false;
        if (this.pos != that.pos)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case VALUE:
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case POS:
            if (field.type == TType.I32) {
              this.pos = iprot.readI32();
              this.__isset.pos = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(POS_FIELD_DESC);
      oprot.writeI32(this.pos);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("replace_at_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
          int __value_size = Math.min(this.value.length, 128);
          for (int i = 0; i < __value_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
          }
          if (this.value.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pos:");
      sb.append(this.pos);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class replace_at_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("replace_at_result");
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(replace_at_result.class, metaDataMap);
    }

    public replace_at_result() {
    }

    public replace_at_result(
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public replace_at_result(replace_at_result other) {
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public replace_at_result clone() {
      return new replace_at_result(this);
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof replace_at_result)
        return this.equals((replace_at_result)that);
      return false;
    }

    public boolean equals(replace_at_result that) {
      if (that == null)
        return false;

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("replace_at_result(");
      boolean first = true;

      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class retrieve_at_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("retrieve_at_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField POS_FIELD_DESC = new TField("pos", TType.I32, (short)4);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public int pos;
    public static final int POS = 4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean pos = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(POS, new FieldMetaData("pos", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(retrieve_at_args.class, metaDataMap);
    }

    public retrieve_at_args() {
    }

    public retrieve_at_args(
      String bucket,
      String key,
      int pos)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.pos = pos;
      this.__isset.pos = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public retrieve_at_args(retrieve_at_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      __isset.pos = other.__isset.pos;
      this.pos = other.pos;
    }

    @Override
    public retrieve_at_args clone() {
      return new retrieve_at_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public int getPos() {
      return this.pos;
    }

    public void setPos(int pos) {
      this.pos = pos;
      this.__isset.pos = true;
    }

    public void unsetPos() {
      this.__isset.pos = false;
    }

    // Returns true if field pos is set (has been asigned a value) and false otherwise
    public boolean isSetPos() {
      return this.__isset.pos;
    }

    public void setPosIsSet(boolean value) {
      this.__isset.pos = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case POS:
        if (value == null) {
          unsetPos();
        } else {
          setPos((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case POS:
        return new Integer(getPos());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case POS:
        return isSetPos();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof retrieve_at_args)
        return this.equals((retrieve_at_args)that);
      return false;
    }

    public boolean equals(retrieve_at_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_pos = true;
      boolean that_present_pos = true;
      if (this_present_pos || that_present_pos) {
        if (!(this_present_pos && that_present_pos))
          return false;
        if (this.pos != that.pos)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case POS:
            if (field.type == TType.I32) {
              this.pos = iprot.readI32();
              this.__isset.pos = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(POS_FIELD_DESC);
      oprot.writeI32(this.pos);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("retrieve_at_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("pos:");
      sb.append(this.pos);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class retrieve_at_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("retrieve_at_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public byte[] success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(retrieve_at_result.class, metaDataMap);
    }

    public retrieve_at_result() {
    }

    public retrieve_at_result(
      byte[] success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public retrieve_at_result(retrieve_at_result other) {
      if (other.isSetSuccess()) {
        this.success = new byte[other.success.length];
        System.arraycopy(other.success, 0, success, 0, other.success.length);
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public retrieve_at_result clone() {
      return new retrieve_at_result(this);
    }

    public byte[] getSuccess() {
      return this.success;
    }

    public void setSuccess(byte[] success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((byte[])value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof retrieve_at_result)
        return this.equals((retrieve_at_result)that);
      return false;
    }

    public boolean equals(retrieve_at_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!java.util.Arrays.equals(this.success, that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBinary(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("retrieve_at_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
          int __success_size = Math.min(this.success.length, 128);
          for (int i = 0; i < __success_size; i++) {
            if (i != 0) sb.append(" ");
            sb.append(Integer.toHexString(this.success[i]).length() > 1 ? Integer.toHexString(this.success[i]).substring(Integer.toHexString(this.success[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.success[i]).toUpperCase());
          }
          if (this.success.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class range_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("range_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
    private static final TField START_FIELD_DESC = new TField("start", TType.I32, (short)3);
    private static final TField END_FIELD_DESC = new TField("end", TType.I32, (short)4);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;
    public int start;
    public static final int START = 3;
    public int end;
    public static final int END = 4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean start = false;
      public boolean end = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(END, new FieldMetaData("end", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(range_args.class, metaDataMap);
    }

    public range_args() {
    }

    public range_args(
      String bucket,
      String key,
      int start,
      int end)
    {
      this();
      this.bucket = bucket;
      this.key = key;
      this.start = start;
      this.__isset.start = true;
      this.end = end;
      this.__isset.end = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public range_args(range_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
      __isset.start = other.__isset.start;
      this.start = other.start;
      __isset.end = other.__isset.end;
      this.end = other.end;
    }

    @Override
    public range_args clone() {
      return new range_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public int getStart() {
      return this.start;
    }

    public void setStart(int start) {
      this.start = start;
      this.__isset.start = true;
    }

    public void unsetStart() {
      this.__isset.start = false;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.__isset.start;
    }

    public void setStartIsSet(boolean value) {
      this.__isset.start = value;
    }

    public int getEnd() {
      return this.end;
    }

    public void setEnd(int end) {
      this.end = end;
      this.__isset.end = true;
    }

    public void unsetEnd() {
      this.__isset.end = false;
    }

    // Returns true if field end is set (has been asigned a value) and false otherwise
    public boolean isSetEnd() {
      return this.__isset.end;
    }

    public void setEndIsSet(boolean value) {
      this.__isset.end = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      case START:
        if (value == null) {
          unsetStart();
        } else {
          setStart((Integer)value);
        }
        break;

      case END:
        if (value == null) {
          unsetEnd();
        } else {
          setEnd((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      case START:
        return new Integer(getStart());

      case END:
        return new Integer(getEnd());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      case START:
        return isSetStart();
      case END:
        return isSetEnd();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof range_args)
        return this.equals((range_args)that);
      return false;
    }

    public boolean equals(range_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_start = true;
      boolean that_present_start = true;
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (this.start != that.start)
          return false;
      }

      boolean this_present_end = true;
      boolean that_present_end = true;
      if (this_present_end || that_present_end) {
        if (!(this_present_end && that_present_end))
          return false;
        if (this.end != that.end)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.I32) {
              this.start = iprot.readI32();
              this.__isset.start = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case END:
            if (field.type == TType.I32) {
              this.end = iprot.readI32();
              this.__isset.end = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(START_FIELD_DESC);
      oprot.writeI32(this.start);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(END_FIELD_DESC);
      oprot.writeI32(this.end);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("range_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      sb.append(this.start);
      first = false;
      if (!first) sb.append(", ");
      sb.append("end:");
      sb.append(this.end);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class range_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("range_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public List<byte[]> success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(range_result.class, metaDataMap);
    }

    public range_result() {
    }

    public range_result(
      List<byte[]> success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public range_result(range_result other) {
      if (other.isSetSuccess()) {
        List<byte[]> __this__success = new ArrayList<byte[]>();
        for (byte[] other_element : other.success) {
          byte[] temp_binary_element = new byte[other_element.length];
          System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
          __this__success.add(temp_binary_element);
        }
        this.success = __this__success;
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public range_result clone() {
      return new range_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<byte[]> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(byte[] elem) {
      if (this.success == null) {
        this.success = new ArrayList<byte[]>();
      }
      this.success.add(elem);
    }

    public List<byte[]> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<byte[]> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<byte[]>)value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof range_result)
        return this.equals((range_result)that);
      return false;
    }

    public boolean equals(range_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list4 = iprot.readListBegin();
                this.success = new ArrayList<byte[]>(_list4.size);
                for (int _i5 = 0; _i5 < _list4.size; ++_i5)
                {
                  byte[] _elem6;
                  _elem6 = iprot.readBinary();
                  this.success.add(_elem6);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (byte[] _iter7 : this.success)          {
            oprot.writeBinary(_iter7);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("range_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class length_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("length_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);

    public String bucket;
    public static final int BUCKET = 1;
    public String key;
    public static final int KEY = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(length_args.class, metaDataMap);
    }

    public length_args() {
    }

    public length_args(
      String bucket,
      String key)
    {
      this();
      this.bucket = bucket;
      this.key = key;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public length_args(length_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetKey()) {
        this.key = other.key;
      }
    }

    @Override
    public length_args clone() {
      return new length_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
    }

    public void unsetKey() {
      this.key = null;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.key != null;
    }

    public void setKeyIsSet(boolean value) {
      if (!value) {
        this.key = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case KEY:
        if (value == null) {
          unsetKey();
        } else {
          setKey((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case KEY:
        return getKey();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case KEY:
        return isSetKey();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof length_args)
        return this.equals((length_args)that);
      return false;
    }

    public boolean equals(length_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_key = true && this.isSetKey();
      boolean that_present_key = true && that.isSetKey();
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("length_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      if (this.key == null) {
        sb.append("null");
      } else {
        sb.append(this.key);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class length_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("length_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public int success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(length_result.class, metaDataMap);
    }

    public length_result() {
    }

    public length_result(
      int success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public length_result(length_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public length_result clone() {
      return new length_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof length_result)
        return this.equals((length_result)that);
      return false;
    }

    public boolean equals(length_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("length_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class scan_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_args");
    private static final TField BUCKET_FIELD_DESC = new TField("bucket", TType.STRING, (short)1);
    private static final TField SEED_FIELD_DESC = new TField("seed", TType.STRING, (short)2);
    private static final TField LIMIT_FIELD_DESC = new TField("limit", TType.I32, (short)3);

    public String bucket;
    public static final int BUCKET = 1;
    public String seed;
    public static final int SEED = 2;
    public int limit;
    public static final int LIMIT = 3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean limit = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BUCKET, new FieldMetaData("bucket", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SEED, new FieldMetaData("seed", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(LIMIT, new FieldMetaData("limit", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(scan_args.class, metaDataMap);
    }

    public scan_args() {
    }

    public scan_args(
      String bucket,
      String seed,
      int limit)
    {
      this();
      this.bucket = bucket;
      this.seed = seed;
      this.limit = limit;
      this.__isset.limit = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_args(scan_args other) {
      if (other.isSetBucket()) {
        this.bucket = other.bucket;
      }
      if (other.isSetSeed()) {
        this.seed = other.seed;
      }
      __isset.limit = other.__isset.limit;
      this.limit = other.limit;
    }

    @Override
    public scan_args clone() {
      return new scan_args(this);
    }

    public String getBucket() {
      return this.bucket;
    }

    public void setBucket(String bucket) {
      this.bucket = bucket;
    }

    public void unsetBucket() {
      this.bucket = null;
    }

    // Returns true if field bucket is set (has been asigned a value) and false otherwise
    public boolean isSetBucket() {
      return this.bucket != null;
    }

    public void setBucketIsSet(boolean value) {
      if (!value) {
        this.bucket = null;
      }
    }

    public String getSeed() {
      return this.seed;
    }

    public void setSeed(String seed) {
      this.seed = seed;
    }

    public void unsetSeed() {
      this.seed = null;
    }

    // Returns true if field seed is set (has been asigned a value) and false otherwise
    public boolean isSetSeed() {
      return this.seed != null;
    }

    public void setSeedIsSet(boolean value) {
      if (!value) {
        this.seed = null;
      }
    }

    public int getLimit() {
      return this.limit;
    }

    public void setLimit(int limit) {
      this.limit = limit;
      this.__isset.limit = true;
    }

    public void unsetLimit() {
      this.__isset.limit = false;
    }

    // Returns true if field limit is set (has been asigned a value) and false otherwise
    public boolean isSetLimit() {
      return this.__isset.limit;
    }

    public void setLimitIsSet(boolean value) {
      this.__isset.limit = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BUCKET:
        if (value == null) {
          unsetBucket();
        } else {
          setBucket((String)value);
        }
        break;

      case SEED:
        if (value == null) {
          unsetSeed();
        } else {
          setSeed((String)value);
        }
        break;

      case LIMIT:
        if (value == null) {
          unsetLimit();
        } else {
          setLimit((Integer)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return getBucket();

      case SEED:
        return getSeed();

      case LIMIT:
        return new Integer(getLimit());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BUCKET:
        return isSetBucket();
      case SEED:
        return isSetSeed();
      case LIMIT:
        return isSetLimit();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scan_args)
        return this.equals((scan_args)that);
      return false;
    }

    public boolean equals(scan_args that) {
      if (that == null)
        return false;

      boolean this_present_bucket = true && this.isSetBucket();
      boolean that_present_bucket = true && that.isSetBucket();
      if (this_present_bucket || that_present_bucket) {
        if (!(this_present_bucket && that_present_bucket))
          return false;
        if (!this.bucket.equals(that.bucket))
          return false;
      }

      boolean this_present_seed = true && this.isSetSeed();
      boolean that_present_seed = true && that.isSetSeed();
      if (this_present_seed || that_present_seed) {
        if (!(this_present_seed && that_present_seed))
          return false;
        if (!this.seed.equals(that.seed))
          return false;
      }

      boolean this_present_limit = true;
      boolean that_present_limit = true;
      if (this_present_limit || that_present_limit) {
        if (!(this_present_limit && that_present_limit))
          return false;
        if (this.limit != that.limit)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BUCKET:
            if (field.type == TType.STRING) {
              this.bucket = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SEED:
            if (field.type == TType.STRING) {
              this.seed = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case LIMIT:
            if (field.type == TType.I32) {
              this.limit = iprot.readI32();
              this.__isset.limit = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.bucket != null) {
        oprot.writeFieldBegin(BUCKET_FIELD_DESC);
        oprot.writeString(this.bucket);
        oprot.writeFieldEnd();
      }
      if (this.seed != null) {
        oprot.writeFieldBegin(SEED_FIELD_DESC);
        oprot.writeString(this.seed);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(LIMIT_FIELD_DESC);
      oprot.writeI32(this.limit);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scan_args(");
      boolean first = true;

      sb.append("bucket:");
      if (this.bucket == null) {
        sb.append("null");
      } else {
        sb.append(this.bucket);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("seed:");
      if (this.seed == null) {
        sb.append("null");
      } else {
        sb.append(this.seed);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("limit:");
      sb.append(this.limit);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class scan_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("scan_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField EX1_FIELD_DESC = new TField("ex1", TType.STRUCT, (short)1);
    private static final TField EX2_FIELD_DESC = new TField("ex2", TType.STRUCT, (short)2);

    public List<String> success;
    public static final int SUCCESS = 0;
    public ThrudocException ex1;
    public static final int EX1 = 1;
    public InvalidBucketException ex2;
    public static final int EX2 = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      put(EX1, new FieldMetaData("ex1", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      put(EX2, new FieldMetaData("ex2", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(scan_result.class, metaDataMap);
    }

    public scan_result() {
    }

    public scan_result(
      List<String> success,
      ThrudocException ex1,
      InvalidBucketException ex2)
    {
      this();
      this.success = success;
      this.ex1 = ex1;
      this.ex2 = ex2;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public scan_result(scan_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetEx1()) {
        this.ex1 = new ThrudocException(other.ex1);
      }
      if (other.isSetEx2()) {
        this.ex2 = new InvalidBucketException(other.ex2);
      }
    }

    @Override
    public scan_result clone() {
      return new scan_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getEx1() {
      return this.ex1;
    }

    public void setEx1(ThrudocException ex1) {
      this.ex1 = ex1;
    }

    public void unsetEx1() {
      this.ex1 = null;
    }

    // Returns true if field ex1 is set (has been asigned a value) and false otherwise
    public boolean isSetEx1() {
      return this.ex1 != null;
    }

    public void setEx1IsSet(boolean value) {
      if (!value) {
        this.ex1 = null;
      }
    }

    public InvalidBucketException getEx2() {
      return this.ex2;
    }

    public void setEx2(InvalidBucketException ex2) {
      this.ex2 = ex2;
    }

    public void unsetEx2() {
      this.ex2 = null;
    }

    // Returns true if field ex2 is set (has been asigned a value) and false otherwise
    public boolean isSetEx2() {
      return this.ex2 != null;
    }

    public void setEx2IsSet(boolean value) {
      if (!value) {
        this.ex2 = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case EX1:
        if (value == null) {
          unsetEx1();
        } else {
          setEx1((ThrudocException)value);
        }
        break;

      case EX2:
        if (value == null) {
          unsetEx2();
        } else {
          setEx2((InvalidBucketException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case EX1:
        return getEx1();

      case EX2:
        return getEx2();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case EX1:
        return isSetEx1();
      case EX2:
        return isSetEx2();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof scan_result)
        return this.equals((scan_result)that);
      return false;
    }

    public boolean equals(scan_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_ex1 = true && this.isSetEx1();
      boolean that_present_ex1 = true && that.isSetEx1();
      if (this_present_ex1 || that_present_ex1) {
        if (!(this_present_ex1 && that_present_ex1))
          return false;
        if (!this.ex1.equals(that.ex1))
          return false;
      }

      boolean this_present_ex2 = true && this.isSetEx2();
      boolean that_present_ex2 = true && that.isSetEx2();
      if (this_present_ex2 || that_present_ex2) {
        if (!(this_present_ex2 && that_present_ex2))
          return false;
        if (!this.ex2.equals(that.ex2))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  String _elem10;
                  _elem10 = iprot.readString();
                  this.success.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX1:
            if (field.type == TType.STRUCT) {
              this.ex1 = new ThrudocException();
              this.ex1.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case EX2:
            if (field.type == TType.STRUCT) {
              this.ex2 = new InvalidBucketException();
              this.ex2.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter11 : this.success)          {
            oprot.writeString(_iter11);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetEx1()) {
        oprot.writeFieldBegin(EX1_FIELD_DESC);
        this.ex1.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetEx2()) {
        oprot.writeFieldBegin(EX2_FIELD_DESC);
        this.ex2.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("scan_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex1:");
      if (this.ex1 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex1);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("ex2:");
      if (this.ex2 == null) {
        sb.append("null");
      } else {
        sb.append(this.ex2);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class admin_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("admin_args");
    private static final TField OP_FIELD_DESC = new TField("op", TType.STRING, (short)1);
    private static final TField DATA_FIELD_DESC = new TField("data", TType.STRING, (short)2);

    public String op;
    public static final int OP = 1;
    public String data;
    public static final int DATA = 2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(OP, new FieldMetaData("op", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(DATA, new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(admin_args.class, metaDataMap);
    }

    public admin_args() {
    }

    public admin_args(
      String op,
      String data)
    {
      this();
      this.op = op;
      this.data = data;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public admin_args(admin_args other) {
      if (other.isSetOp()) {
        this.op = other.op;
      }
      if (other.isSetData()) {
        this.data = other.data;
      }
    }

    @Override
    public admin_args clone() {
      return new admin_args(this);
    }

    public String getOp() {
      return this.op;
    }

    public void setOp(String op) {
      this.op = op;
    }

    public void unsetOp() {
      this.op = null;
    }

    // Returns true if field op is set (has been asigned a value) and false otherwise
    public boolean isSetOp() {
      return this.op != null;
    }

    public void setOpIsSet(boolean value) {
      if (!value) {
        this.op = null;
      }
    }

    public String getData() {
      return this.data;
    }

    public void setData(String data) {
      this.data = data;
    }

    public void unsetData() {
      this.data = null;
    }

    // Returns true if field data is set (has been asigned a value) and false otherwise
    public boolean isSetData() {
      return this.data != null;
    }

    public void setDataIsSet(boolean value) {
      if (!value) {
        this.data = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case OP:
        if (value == null) {
          unsetOp();
        } else {
          setOp((String)value);
        }
        break;

      case DATA:
        if (value == null) {
          unsetData();
        } else {
          setData((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case OP:
        return getOp();

      case DATA:
        return getData();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case OP:
        return isSetOp();
      case DATA:
        return isSetData();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof admin_args)
        return this.equals((admin_args)that);
      return false;
    }

    public boolean equals(admin_args that) {
      if (that == null)
        return false;

      boolean this_present_op = true && this.isSetOp();
      boolean that_present_op = true && that.isSetOp();
      if (this_present_op || that_present_op) {
        if (!(this_present_op && that_present_op))
          return false;
        if (!this.op.equals(that.op))
          return false;
      }

      boolean this_present_data = true && this.isSetData();
      boolean that_present_data = true && that.isSetData();
      if (this_present_data || that_present_data) {
        if (!(this_present_data && that_present_data))
          return false;
        if (!this.data.equals(that.data))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case OP:
            if (field.type == TType.STRING) {
              this.op = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case DATA:
            if (field.type == TType.STRING) {
              this.data = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.op != null) {
        oprot.writeFieldBegin(OP_FIELD_DESC);
        oprot.writeString(this.op);
        oprot.writeFieldEnd();
      }
      if (this.data != null) {
        oprot.writeFieldBegin(DATA_FIELD_DESC);
        oprot.writeString(this.data);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("admin_args(");
      boolean first = true;

      sb.append("op:");
      if (this.op == null) {
        sb.append("null");
      } else {
        sb.append(this.op);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("data:");
      if (this.data == null) {
        sb.append("null");
      } else {
        sb.append(this.data);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class admin_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("admin_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public String success;
    public static final int SUCCESS = 0;
    public ThrudocException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(admin_result.class, metaDataMap);
    }

    public admin_result() {
    }

    public admin_result(
      String success,
      ThrudocException e)
    {
      this();
      this.success = success;
      this.e = e;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public admin_result(admin_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetE()) {
        this.e = new ThrudocException(other.e);
      }
    }

    @Override
    public admin_result clone() {
      return new admin_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ThrudocException getE() {
      return this.e;
    }

    public void setE(ThrudocException e) {
      this.e = e;
    }

    public void unsetE() {
      this.e = null;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.e != null;
    }

    public void setEIsSet(boolean value) {
      if (!value) {
        this.e = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          setE((ThrudocException)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof admin_result)
        return this.equals((admin_result)that);
      return false;
    }

    public boolean equals(admin_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && this.isSetE();
      boolean that_present_e = true && that.isSetE();
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new ThrudocException();
              this.e.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetE()) {
        oprot.writeFieldBegin(E_FIELD_DESC);
        this.e.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("admin_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      if (this.e == null) {
        sb.append("null");
      } else {
        sb.append(this.e);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
